{"Header": "Lecture7AgileDevelopment", "Link": "www.link.com", "TIME_STAMP": "02:40", "TEXT": "b you're going to learn what you can go to throw that out so through that because you're not building it well you're not worried about architecture functional requirements none of that really matters you're not going to document it either you're not you're not taking care here you're just moving quickly speed over architecture speed over quality that's that's the name of the game here so you know the prototype idea throw it away now what i just people do is they say we should treat all software is provisional we should use pro to types to understand what it is we're trying to do but we should always be ready to throw away that code they won't actually throw away the pro to type keep that put a discipline around how that gets built an expectation from the team that that code is is is going to be continuously revised and so there's nothing there's no reason they would say to to to to throw it out build for deployment always built simple and small keep building keep building keep changing to that's there thinking they're taking that prototype the next thing that doing is thinking about incremental delivery if you were to deliver a piece of software and incremental basis what would you do well you you'd look at all the requirements that everybody has and you'd say which ones are the key ones in which ones are ones we can we can live without well group them the key ones are the ones you do first other requirements might even some group the whole thing group it down set it out into phases and complete the phases after another build up the layers that's a pretty sensible reasonable way of building software and making that is that when you've got a set of requirements that you're going to build you stabilise you don't allow changes around those requirements because that gives some stability for the engineering team to do with is they need to do then you can take on a new bunch of stuff after that so you get the stability but allowing flexibility going forward so that's an idea that they used and but there's the standard process where you see all of that kind of phase development gets done up front in most of those processes and what there what the agile guys are going to say is we should just do this in the continuing basis so deploy early with adopt requirements as we go we get lower project fader risk because of that but we're going to push this to the limit were going to have requirements being identified and decided on possible even as rapidly as once a week it's quite different quite a different approach so why would we need that why would we need all that a rapid development pace and the loss of documentation on all those kinds of ideas well and there is a need for rapid software development and it comes from this back in the eighties people started to strongly automate business processes and strongly automate everything that organisations did so that software had a hand in everything and that gave companies that did that great competitive advantage but it also made them brittle with regard to change if they need to change those processes because it was all in built into the software now and not kind of with people who can be adoptable so you suddenly have to start "}