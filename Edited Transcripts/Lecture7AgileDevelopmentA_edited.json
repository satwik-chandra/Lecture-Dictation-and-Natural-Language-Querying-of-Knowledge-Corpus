{
    "Header": "Lecture7AgileDevelopment",
    "Link": "www.link.com",
    "Transcript": {
        "": "",
        "00:07": "the key idea behind agile software development is that ",
        "00:14": "all software is deployed on an on going basis it's deployed early ideally you know when you redeploy it and you continuously change the code and all you know successful software software that is spent where the engineers who built it spend the majority of the time maintaining fixing that software so the agile people think that really what you need to focus on is software is a continuous adapting process where the code base is continuously being changed and there is to strip way everything that makes that harder so all documentation that slows you down ",
        "00:58": "all all separations between customer and and team that slow that anything that gets in the way that impedes the fast rapid evolution of software that's something you get rid of and that's there is quite brutal so we really really think this if you're if you're not continuously planning for the adaption of the software not really doing software engineering that's there there was thinking about it okay so we're going to go back through the software process models that we talked about before we talk about incremental development again and integration reuse again we're going to work extract out from the exist those existing processes the key ideas that were going to bring into accept not just notice my cameras fickering i've had a number of attempts to record this and i for some reason can get rid of this flickering so i apologise for the firing but this time i just carry on through and if it gets too bad well just was just trying to read of the camera together you won't be able to see me but unfortunately if you going to we need to push on okay so let's look at the ideas that we need to gather and the first idea is an idea that we are all familiar with if you don't know exactly what you're going to build your prototype you see what works with the customers then you you you might use that code base as the basis of of the next thing you do but more likely what you're going to do is you're going to ",
        "02:40": "b you're going to learn what you can go to throw that out so through that because you're not building it well you're not worried about architecture functional requirements none of that really matters you're not going to document it either you're not you're not taking care here you're just moving quickly speed over architecture speed over quality that's that's the name of the game here so you know the prototype idea throw it away now what i just people do is they say we should treat all software is provisional we should use pro to types to understand what it is we're trying to do but we should always be ready to throw away that code they won't actually throw away the pro to type keep that put a discipline around how that gets built an expectation from the team that that code is is is going to be continuously revised and so there's nothing there's no reason they would say to to to to throw it out build for deployment always built simple and small keep building keep building keep changing to that's there thinking they're taking that prototype the next thing that doing is thinking about incremental delivery if you were to deliver a piece of software and incremental basis what would you do well you you'd look at all the requirements that everybody has and you'd say which ones are the key ones in which ones are ones we can we can live without well group them the key ones are the ones you do first other requirements might even some group the whole thing group it down set it out into phases and complete the phases after another build up the layers that's a pretty sensible reasonable way of building software and making that is that when you've got a set of requirements that you're going to build you stabilise you don't allow changes around those requirements because that gives some stability for the engineering team to do with is they need to do then you can take on a new bunch of stuff after that so you get the stability but allowing flexibility going forward so that's an idea that they used and but there's the standard process where you see all of that kind of phase development gets done up front in most of those processes and what there what the agile guys are going to say is we should just do this in the continuing basis so deploy early with adopt requirements as we go we get lower project fader risk because of that but we're going to push this to the limit were going to have requirements being identified and decided on possible even as rapidly as once a week it's quite different quite a different approach so why would we need that why would we need all that a rapid development pace and the loss of documentation on all those kinds of ideas well and there is a need for rapid software development and it comes from this back in the eighties people started to strongly automate business processes and strongly automate everything that organisations did so that software had a hand in everything and that gave companies that did that great competitive advantage but it also made them brittle with regard to change if they need to change those processes because it was all in built into the software now and not kind of with people who can be adoptable so you suddenly have to start ",
        "06:21": "re working the software and that turned out to be very slow and an engineers who were trying to do this work were failing to deliver on time all the time because they were working to plan driven models and i just didn't work and so the the thinking at the time was that we've got to find a better way to do this we've got to be able to be more responsive and more adaptable to our end users and they ask themselves what stopping us and there answer was there existing plan driven development plants that they weren't responsive enough they weren't going to give them the flexibilities that they needed so in the nineteen nineties they decided on a different way of thinking and the thinking i think is encouraged recently well in this this phrase working backwards it's all about working software systems and then everything we do is about reducing delivery time of that so agile development aims to reduce delivery time for working software systems and everything is stripped away that doesn't meet that go so working code is all that matters building it in increments so that we can adapt to what users need that matters getting the the development getting the developers and the clients together to decide what needs to be built in the next short increment of possibly days more likely two weeks there that you know potentially days continuous negotiation of what should go into the software on an on going basis releasing that software in a continuing basis and i really do apologise for the flickering but unfortunately im having some technical difficult here that i cannot overcome so we just have to live with it and tools a lot of tools because there is no documentation you really got to make sure that engineers are following processes and communicating information to each other well using communication tools and software tools ok ",
        "08:25": "right so just a very brief picture again that what we looking out here we're looking at the difference between plan driven and agile sorry i went to the difference between plan driven and ago so plan driven rid of that image just because it's flickering so much so my apart is for a moment i want i record this at some point when we can when i can fix this technical difficult to it for the moment bare with me i'm still here invoice and i just continue with the slides so what we're looking at here is plan driven vs agile development just to re emphasise again the items between what came before and what came after so in plan based development you're doing all the documentation and development and design of the process and the software up front you're developing all the requirements and then you're handing that to the design team who then build stuff and then yes you can iterate but it's very slow process round and around that way there's a separation between clients and and developers in the ",
        "09:39": "agent development method you're doing requirements engineering and design and implementation at the same time and there's no documentation to speak of you know there's stuff on pieces of paper on wall things like that it's a very lightweight process continuous innovation between customers and developers as the software gets built that's the basic idea ok so they say they came up with a man festive and just see if we can ring back this ",
        "11:07": "and that started a really revolution to be honest now of the first task for you the first thing i want you to do is i want you to go to that website and i want you to find stat manifest to and also just read around this is a website that kind of promotes agile ",
        "11:32": "software development have a read and explore so that's the the first thing i want you to do we're not going to go through that manifest of any any great detail i will i will go through some of the basic principles here though so just to give again a sense of what it is there about so the first is customer involvement close customer involvement customers and some abstract individual customer is is is a person sitting in the in the office with the engineering team deciding on things a daily wake basis so genuine involvement and incremental delivery where the customer is the one deciding on what's to be included in different increments okay so that that that customer representative is in there working out almost a product champion working at what should be should be happening in this thing and the team are working to that individual and working with that individual or potentially individuals let's just keep it simple as one next ideas no ",
        "12:45": "trust it it kind of trust people to come up with good ways to work i think that's the best way to describe this i've heard these guys talking about this stuff that they don't believe in software engineering processes you know specific ways this is how you do bug fixing that kind of idea they just want people to have freedom to find the best way to work and they kind of trust that that will deliver ",
        "13:16": "gps the next one is about just to basic idea of change that you know the software should be built with the expectation that the software will be changed that means that you don't optimise things early for example that means that you are quite happy to solve a complex problem in a rudimentary way to begin with because you know that code can go when something more sophisticated is needed so you know you're not going to sit around hoping that your code is going to be sitting in the software for you know years if not decades you know if your software if to code you write to the last couple of weeks well that's that's probably good but don't worry about it if it doesn't that you know continuous change the next piece i think is is is important that we seen this before you know it's hard to write software that's simple because software has to do such complex things these people are saying is don't worry about the complexting quite quite a different way of thinking ",
        "14:48": "bt some of the some of the the the ideas we had around complexity already you know if complexities the hard thing then not trying to solve the hard thing might might turn to be a good idea i will will think about this in a while but certainly this is an interesting motivation keep things simple simple keep things rapidly evolving that the customers drive what needs to be done these are these are kind of new this is a new way of thinking about problems that the old solutions just weren't solving the other one any full can write code that computer can understand good programmers right code that humans can understand really important in messages because there's no documentation says no point in writing and no documentation means no big long comments either so it's not just no paper documentation or diagrams are modeling no they don't want anyone to have to do much more than to read the code in an ideal world some of these guys are quite cool about this but you know they're experienced to so they they do also know what to talking about interesting it is now think for a moment how far we've moved from margaret hamilton so margaret hamilton set out to make software engineering a real engineering discipline now any of you know about engineering that and that that means process that means you know applying specific methods to ensure safety and you know structure and you know quite quite a lot of theory you know breaches get built carefully and slowly they don't get thrown together you know in that in and in a dorm room with pizza you know marvelous mission was to to make engineering a formal well regulated structured process to delivered high quality you know and she was responsible for you know code basis that never never broke so you know you have to give that view a lot of respect but quickly it's it's not about really nailing down requirements on and getting sign off and so on it's about it's a it's a much more important improvisational kind of approach ",
        "17:44": "if you should so that's you know it's it's a different it's definitely a different direction worth looking at this i think you should have a read of this ",
        "17:57": "it give you a little bit more detail the system an article is a bit link up there give you a little bit more detail around margaret hamilton's views of ",
        "18:12": "how software engineering should be done this is obviously recent times ",
        "18:20": "you know she she's she's not advocating dispensing the documentation so on she she really isn't she's she's actually talking about model driven development using more formal methods to capture correct software and it's a very different direction so so i i'm introducing this to you because i want you to get a sense that you know this is a debate and maybe even we'll talk about this on wed ",
        "19:10": "engineers really well then one has to ask is it because it makes life easy for the engineers or is it that that it's used or is it because it delivers genuinely better software where can i just be applied and what kind of structures are necessary for it to work it's it's it's not a one size fiddle proposition but for lots of classes a software that we use and build its it's definitely the right model so anyway this is what hamilton has to say ",
        "19:57": "this is a comment in this article ",
        "20:03": "just to give you a flavor of it you know ",
        "20:07": "se she she she really thinks that there's a lot wrong with her things are being done and since putting that way so i think have a read whether you you agree or not with what she has to say ok so here's the real question then so we've got a sense of what i live is this highly flexible approach and we look at extreme programming next week which is a particular flavor of agile development but we've got this ",
        "20:36": "highly flexible highly adaptable approach to doing software that document life that in beds the customer with the with the software team and that is very hard to know what's going to happen next because you know what happens next might only be invented this week lots of lots of communication backwards and forwards and people leaving channels open that kind of thing so it can work very well for remote teams they need to be co located in a meaningful way even if it is virtually ",
        "22:05": "a lot of the thinking around that is not what makes it work in the absence of decent documentation is a sort of a group knowledge of the software code base and i methods encourage people to to modify and edit all of the code base and it discourages specialisation very strongly and that's all about building a sort of a team understanding a team knowledge of the code base so that it's everyone ever kind of knows what's going on that the thinking you know from research circles is is that that that needs a level of collaboration and communication ",
        "22:56": "informal using informal channels that just isn't necessary and in more straight forward document driven plan software development models so you know i hope you're getting the sense of it it's very kind of see to the plans pants and loose but there are processes as we'll see next week there are very strong processes to put some structure on that but the feel of it is you know very creative very flexible anything could be done this week next week with it let's just see how we go some kind of a flavor rather than you know the gams chart says we should be set you know beginning section six point two one function requirement document a so probably more like the way you do group work today than than you might might expect okay the other thing it's good for is ",
        "24:03": "software of any scale really but that's been done within a large organisation and you know an organisation that has the time in the space to to support ",
        "24:18": "you know at a team in terms of being able to explain requirement needs and work with some closely so on so it suits that those kinds of environments as well where's it not work well well it it doesn't work very well in projects that are driven by contracts ",
        "24:43": "in anywhere with the project is you know based on large long legal complex texts about delivery you know functional requirements and so on being part of that it doesn't work well obvious reasons ",
        "25:07": "the next place work doesn't seem to work very well is in software maintenance which is kind of ironic but part of the problem with software maintenance is maintenance quite a long term long duration and if you don't have a lot of documentation in place it can be very hard for people to you know you can remember what a code based did when they wrote it three years ago so think of it this way agile development seems to require a group knowledge of the software and then the question becomes how far back in that stretch realistically before knowledge is lost and you know part of the system become an effectively good fashion undocumented hard to maintain legacy code so that's an issue and given that most successful software spend most of its time in the maintenance face where functionalities being added but exacted to existing potentially large code base that don't seem to have you know some serious negatives to it you know some maybe it's good for version one of a product but then you need to start doing other things i'm only posing these as ideas for you for the moment ",
        "26:32": "doesn't work very well we've spoken about you know well virtually co located people ",
        "26:57": "but once you start distributing teams around the world you start to get real problems with times differences we did some work where we found that we could we could spot scenarios where you know a team trying to fix a problem that you know spread across t members maybe over three three three three times on set say dublin los angeles and the filipines something like that and we can see ",
        "27:38": "gosh you know two days of development work could easily stretch to seven eight nine days where the vast majority of that stretch is due to just problems getting team members able to synchronise and talk to each other shocking how long the delays can end up being and when software engineers are busy doing lots of things at once and where teams effectively form to solve particular problems and that arise it's extremely hard for engineers to be able to track how many of these kind of activities are getting the delayed really really delayed imagine asking for a simple change to a software system and the team fails to do it in three weeks and they haven't even realised that there failing those kinds of scenarios something we've got really complex ",
        "28:36": "ds of people it can be really hard to make this work again it's all about the communication across the team ok the contract problem who is looking at the potential for this contract so here's the challenge with contracts are generally speaking written in terms of specifications software specifications in the words what functionality is this software system supposed to deliver but angile software development if there's kind of one singer feature it's it's that there is no real specifications up front so we don't know what the system is going to do because we haven't yet discovered by working with the customer what it needs to do so you can specify some things but an all the lot gets left unknown and it's very hard to know if progress is being made because software that's been written maybe has to go get re written at a later stage in a deep way maybe it's really junk software that is only a place holder while they work another thing so it's very hard to gauge progress as well so ",
        "29:52": "y really hard job for managers to be able to report on whether or not an agile development team is actually making progress "
    }
}