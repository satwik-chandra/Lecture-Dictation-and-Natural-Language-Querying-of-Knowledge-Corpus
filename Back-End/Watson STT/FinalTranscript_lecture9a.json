{
  "Header": "lecture9a",
  "Link": "Link.com",
  "Transcript": "\n[00:07]so good morning monday perhaps monday bank holiday monday possibly more likely tuesday so the first of two videos this week obviously the theoretical one and the practical one this theoretical one is is focusing on extreme programming which is a specific methodology in the agile and space so it's kind of like the granddaddy of all agile development it's kind of the thing that comes first it's the it's the methodology that the key proponents of that job development and put together and you know live by and swear by to this day there are detractors there are advocates for this particular methodology but i think what it what it gives us for our purposes is is a real hard core agile development methodology so we'll see really what it looks like there are a series of different practices and principles come together to form this particular way of working this maybe the way you'll work when you work in groups later on in the year and this may something you decide you want to stay care of for the rest of your life it can be quite an extreme it can raise quite extreme responses it's it's quite unique but enough of me waffling on extreme programming is the name of it it's sometimes called XP and you know people talk about x XP is xp development you know XP tools and so on invented by this guy there are others in the mix but i think he's the most he's the most important so this is this is kent beck and around about nineteen ninety six he joined a team that was building something called the chrysler comprehensive compensation system you know exciting stuff very big system now kent back at the time was a you know well known small talk developer and object oriented guy and the chrysler people brought him in because they want to help them sort out some problems in the in the development and so he joined about nineteen ninety six and i spent three or four years there and so by nineteen ninety nine kind of a series of ideas that had collective around his working there with teams on this so called c three system had led him to a place where he felt that really software development to work in quite a different way this is an interesting guy right isn't a one trick pony is you know major characterist design patterns movement pieces as well so you know serious guy so nineteen ninety nine is recently passed away was jump there wasn't a band extreme and he decided to call his programming methodology i like to think about to that stuff extreme programming and this is his book extreme programming explain the first edition i think it was nineteen ninety nine and there are a series of principles at the bottom there that he felt were important to make part of any software development methodology that was going to actually deliver and work and then he developed a series of practices with his colleagues to to to make those principles work so you know that's important in any methodology you may have a serious series of values of principles you want to try and build into your your your your approach but then you've got to work out how that's actually going to be delivered in practice because you're going to deal with real engineers real people who you know apply that seven plus or minus two rule can only do so much can only can only keep up with a certain methodology if if if there are things that those people can follow you can lead by saying go ahead and do the job you have to give people some way of moving forwards so let's look at the the principles if if if you like on the bottom so let's let's go kind of from the top right simple design will work away around clockwise so keep the soft we've seen some of these before because the agile development methodology maps to thinking here so you know keep keep keep to design of the software simple do a lot of testing to talk about something is test first now you have heard of test riven development test first development is a kind of extreme version of that idea continuous refactory and he doesn't just mean you know fixing things when they go wrong it means continuously fixing things remember this extreme methodology is kind of like take it all to the to to to eleven small releases as in maybe release two or three times a day okay it's like extreme and incremental planning and the key there is don't plan forwards too far okay so your you are incremental planning really means in a way don't plan to far ahead to do the planning incrementally and then on top of that we get a couple of quite interesting ideas and we'll go again from the top right and so collective ownership so this is the idea that nobody gets to own any particular code that you might come in in the morning having worked on code to find someone else has changed it and because they needed it to do something slightly different and you don't get annoyed by that okay and say that could only really work if people have source control good source control and they capacity to merge different branches and so on and but somebody of completing some task might might go to any part of the code basin and work so you don't get to be a specialist in the graphics or the user interface into sign you have to be kind of jack of all trades and you have to be able to move everywhere and we'll see why in a moment and yeah everybody else the code based a collective piece the next one is sustainable pace um you probably all family with the idea of you know software developers with pizza and working in the four o'clock in the morning working away and trying to get the code ready for the release that's not allowed in this methodology the work has to proceed at a pace that allows for people to go home there's no overtime a note okay so everything has to move smoothly and evenly that's one of these these kind of practices that go with the principles um the customers on sight we spoken about that before i won't labour it need somebody in place to be able to tell us what the system needs to be at all times continuous integration that's all different parts of the software system being built by various team members have to be made work together all the time that's very different from the sort of the increment or the even the incremental methods but the the waterfall methods where software components would only be brought together at the various and each part was built to spec and so therefore they should work together often people find the don't for various interdependency reasons and then the the final one which is kind of like the weirdest one is pair programming and mention this before but this is the annual you know show you some photos and i'll point you since some videos later genuinely the idea where you do not do any software programming unless you've got a partner can only police in a police car you know you've got a partner who's going to do that with you and not that your parallel play you're not sitting side by side doing different things you're actually working on the same piece of code together you're looking at the same code you're you're both doing the one task that sounds like a to any project manager that sounds insane because you're using two people to do one job these guys say this is a better way of doing things okay so that's kind of go through some of the just pick out some of the key features here as we go and i promise too long on this one so the first thing is the iterations so what does the iteration look like we know in agile it's going to be kind of iterative it's going to do pieces of work we're going to build forwards to allow ourselves to change code and so on the extreme ideas that you know you might you might do a complete bill to the software a few times a day you will deliver increments every two weeks and other methodologies we'll talk about be longer but we're really talking about you know maybe in a week one to two weeks all tests up to run all the time and nothing it's accepted unless the tests are working there methodologies allow a little bit more flexibility there because there's a longer lead time from you know deciding to take on work to the end but in this methodology now you don't you don't commit any code that doesn't were perfectly against everything you don't consider a piece of work finished a line of code correct unless it run against and tests i have even seen some people in the past doing this type of work am setting up automated continuous testing so that every time anybody changes some code they are getting feedback very regularly around whether or not the code they have written even if they haven't committed it yet would break the tests guy so there's a strong emphasis here on testing being part of the programming process that's the that's the kind of that the mind set to get from this this isn't just a oh i written the code now i'll see if the tests are run before i build it snow i am continuously as part of my development as part of my programming i am i am running tests every time i make a significant change to a function or class i'll run the test to see if i've broken anything kind of like what i was starting to show you the other day when i was doing some unit testing imagine running those unit test told more often than you're running the compiler think of it that way okay so that's iterations now this is the the book that the suffering general because it's sort of a slightly different take on this on the life cycle extreme programming you know the process and i think this is better that this is taken from extreme programming organisation the home site for these guys and unfortunately their display there their way of displaying images isn't great this is slightly grainy but i think you can you can see it so the key pieces in the center is the iteration and if you if you kind of watch the the trajectory there you go from an iteration to tests that if there accepted may leave me lead to it to a release of software to the customer we've kind of got that idea before giving you now the context which is this could be very rapid and could be daily or even morning and afternoon you never know and then we swing around after after an iteration is completing tests or complete back to the next iteration okay now the question and becomes how do things get into the iteration and that's to do with planning okay and there's a very unique way in which extreme programming projects end up creating the tasks that that end up being put into the iteration and it is a particular process by which tasks are are selected into an iteration extreme programming will we look at that before we look at that let's just tidy up a couple of other things so the first is you know the the entry into the system as a whole is user stories and we're going to look at one of these literally just scraps of paper there's no document documentation going on here at all we're just literally talking about you know just to complete out your understanding of this picture spikes are about experimental research driven pieces of works you might say we don't know what the base best database that best database technology is to use for this project so let's do a small max two week piece of research work and no matter whether that work is completed and deliver something useful it finishes after that period so these are the idea that we might we might have some iterations effectively become kind of a throwaways and in the the terminology we've been been using up to date but essentially then what we get is user stories create requirements and the requirements will see just scraps that also deliver scenarios that need to be tested all of those scraps of paper go into the release planning is a specific way of doing that that we look at in a moment and that starts to feed tasks into the iterations and a way to go and they blast hard for one or two weeks and then come back for air and grab more okay so that's your basic process it is essentially in agile process and there are some there are some interesting tweaks in there we'll see a bit more coming up there okay so the and website the idea here is that the user stories former a sort of a big bag and anything could be chosen and there are some basic principles for what you might choose like for example you might choose things that are you know what would be called the highest r y return on investment you know this this stuff to that is going to deliver maximum impact for minimum amount of effort and they might be the things that you want to do first or you might be let's lay down the architectural stuff first that might be the stuff you want to do first you know they'll be a combination the idea behind extreme programming really has trust the engineers and trust to customers and they'll work it out so there's there's no hard fast rule here so work at what needs to be done think about it in terms of the estimates of the time it's going to take and then fit the time you have to the tasks you are done in that time okay but but keep your iterations solid so rather than kind of say we need to do task a and task b whatever time it's going to take you say let's pick things that we can shit into our iteration cycle let's see what we can fit in there we'll let the developers tell us how long these things are going to take so you're not going to have some analysts separate from the development process going to do this no the engineers were going to do this work we'll tell you how long this is gonna take and then it's the customer who chooses what gets done and the pretty pretty strong about that it's not the engineers there are agile methods where it's the kind of the engineering team we decide ultimately and the customers kind of advise but no the extreme programmers say no it's the customer who makes these decisions okay developers will effectively kind of like a doctor telling okay you've got you know some some illness and these are the possible treatments that we could do here are the positives and benefits what do you want to do kind of similar idea so you could do this we could do that these are the options what you want to do the customer has to be really really embedded in this process for to work hopefully that gives you a sense of it so that there's a a customer story task card there's no document doing an analysis of this there's no there's no complexity at all this somebody writes down some stuff but the the idea of of of this system is that if it's easy and light way to capture stuff and if there are good if there's good communication between the various parties who need to talk to each other and if the team understand the whole code base anyway then this should be enough you shouldn't need heavy documentation cause you're not going to hand this task to somebody who's under familiar with the project and unfamiliar with the customer cause all of these engineers know the customer okay so you see how this works this works because of strong communication between all all the parties right so those cards or something like them maybe a place holder for them end up on boards like these now and there are various variations and put this some key ideas in here if you think about it look what's moving here is cards are you know tasks or things that need to get done there's a backlog that's where all the stuff that we're not doing right now goes there's an on hold that stuff for whatever reasons we can do and then we're making progress at various levels on the other bits and pieces getting done and there's some kind of an organisational structure and you know the the obvious most simple one is things that are to do things that we've done that perhaps need validation with the customer to make sure they're happy acceptance testing and then there's things we plan to do next that have been taken out of the backlog already and put in to give us work to do that kind of okay no although the the extreme programming people tend to be kind of evangelical about the methodologies there isn't one single flavor i don't think i've ever heard of anybody just doing extreme programming and be doing extreme and scroll or that you know there must also look at that they're picking ideas so the way to really think about this is to think of these flavors and to try and get a sense for why somebody might want to do these particular things so put thinking this yourself why would somebody not want to have documentation at all and trust this kind of a model for for building what's what's required what what kind of context environment would be to you know the right one to try these methods and that's obviously this image before i could actually describe some of the projects involved in sometimes you know to give each one of those posted notes there as one of those kind of things in the backlog you know requests feature requests tasks that need to need to get done okay and the question really at the end of the day is given the software is terribly complex all the stuff going on is how how do you make some sense of of all of that and you know that's where we come back to this idea again the extreme programming answer is that the customer decide okay so that we are no longer building a piece of and this is this is crucial coming back to the sort of the contract issues we are no longer building for thee for the customer for the end user a piece of software with agreed specification agreed you know a feature sets and you know a package that that they know it's going to be by the time it finishes we are instead agreeing to work to their direction on the tasks that emerge as the work progresses it's a very different way of working so nobody really knows what kind of software system is going to be built out of this process okay so let's talk about it more about what that actually feels like in practice okay there are there's a planning piece in that in that process and the planning occurs in three stages and this is highly we end up in iterations and you know daily work so so first of all there's the gathering together like i said before in the context of general agile there is to gathering together requirements there literally these pieces of paper and and we kind of try to chunk those remember the iterative development methodology we kind of decide broadly speaking and how those the technically user stories okay so that because there scraps a people scraps of pieces of paper effectively saying what the user would like the system to do okay so they're kind of like sketches of idealised behavior there's no great work on into them they're not they're not designed artifacts yet there's no no one sat down and worked out a sense of change requirements on the existing software it's kind of literally sarah said she'd like to be able to log in from a mobile phone as well as from the desktop you know and xynz maybe a bit more detail but not much more than that so they gather those and you work speaking how you're gonna chunk those as kind of releases to the customer so okay maybe we were going to give you a you know a two weekly and we're going to do these two weekly iterations or sprints but you know let's say yet we're going to get you a baseline mobile app running by you know december and will do six sprints to get there and we'll work out together now what kind of functionality we want into that that that that release okay but it's flexible it may change we may move things you do that kind of iteration level planning but you're not documenting that the way you would in a proper iterative development methodology okay this is loose this is almost you might say trust driven we'll try to get there we'll have to see in your part of the team too you the customer you're part of the team as well so we'll see if we get there but that's what we're going to try to do okay key part of that is that this is the engineering teams that are deciding how long these things tick very important part of this this methodology management don't get to decide the distinct has to be delivered in two months because the customer wants it engineers tell you it's going to take three so maybe we don't want to do that now next piece so once you've got your basic release and you got a sense of you know a bag of story user stories or you know bag of tasks to get done you then move into your iteration planning and then generally call the sprint and that's about taking all of those user stories which are the backlog and selecting at which ones were going to do this next two weeks okay so that's the whole team comes together looks at days estimates works at which ones make most sense that's the customer deciding cause the customer was part of the team engineers estimating how long these things are going to take i'm working out based on that on the available manpower in the available time what things were going to try to get done this next two weeks that's your sprint plan now there are other methodologies that are more document driven scroll example of the methodology that moves on consider perhaps a sideways move from from extreme programming that will have a scroll master you know have some process around around effectively making that decision of what we're just going to do the next few weeks extreme programming is much more around a sort of trust the engineers to work at how this should work kind of approach it's less process heavy they don't really like process you only have the current iteration that you're planning on the table you do not try to plan any of further iterations down the line and does a good reason for that the first reason obviously is that if you are going to start planning all of the iterations then what you're doing really is you're doing an iterative development methodology and they wanted to get away from that kind of thing because those plans usually fail you know iterations don't get done on time and stuff that was supposed to be done in one iteration has to be moved or abandoned the other reason is that because there's no upfront significant design process to this kind of methodology it's not even sure if the kind of things that are in the you know the backlog really makes sense at all there just hints and hunches so this is going to this is going to be refined as you go as you build the system and you learn what it's supposed to do you work at whether or not the stuff that might have gone into the next iteration should have so there's no point in second guessing there's no point in saying i got a plan our iteration to to be ready to only find then that it was rubbish that half the things didn't need to be done and the other half have to be delayed because other things didn't get done that should have you know so it's all about adaptability and flexibility only work on the stuff that's going on right now now if you're familiar with any time management techniques like bullet journaling suggest strongly you look into bullet journal i think it's before i would say it again do look into bullet journaling those methods are often strongly "
}